"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkDXchart"] = self["webpackChunkDXchart"] || []).push([["src_chart_components_code-editor_dxScript_mode-dxscript_js"],{

/***/ "./src/chart/components/code-editor/dxScript/mode-dxscript.js":
/*!********************************************************************!*\
  !*** ./src/chart/components/code-editor/dxScript/mode-dxscript.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initDxScriptEditor: () => (/* binding */ initDxScriptEditor)\n/* harmony export */ });\nfunction parseKeywords(keywordsData) {\n  const categories = {\n    \"\": [],\n    std: [],\n    \"std.series\": [],\n    \"std.array\": [],\n    util: [],\n    math: [],\n    \"math.series\": [],\n    \"math.extended\": [],\n    chart: [],\n    \"math.array\": [],\n    const: [],\n    type: []\n  };\n  function setByCategory(category, value) {\n    if (category && !category.includes(value)) {\n      category.push(value);\n    }\n  }\n  function toCategoryString(arr) {\n    return arr.join(\"|\");\n  }\n  keywordsData.forEach((module) => {\n    if (categories[module.moduleName] || module.moduleName === \"\") {\n      module.keywords.forEach((kw) => {\n        var kwType = kw.keywordType;\n        var kwName = kw.keywordName;\n        if (kwType === \"FUN\") {\n          setByCategory(categories[module.moduleName], kwName);\n          return;\n        }\n        if (kwType === \"CONST\" || kwType === \"SERIES\") {\n          setByCategory(categories[\"const\"], kwName);\n          return;\n        }\n        if (kwType === \"TYPE\") {\n          setByCategory(categories[\"type\"], kwName);\n          return;\n        }\n      });\n    }\n  });\n  for (let key in categories) {\n    categories[key] = toCategoryString(categories[key]);\n  }\n  return categories;\n}\nfunction initDxScriptEditor(keywordsData) {\n  if (!keywordsData) {\n    return;\n  }\n  var categories = parseKeywords(keywordsData);\n  ace.define(\n    \"ace/mode/dxscript_highlight_rules\",\n    [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/lib/lang\", \"ace/mode/text_highlight_rules\"],\n    function(require, exports) {\n      var oop = require(\"../lib/oop\");\n      var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n      var keywords = \"in|def|out|set|if|then|else|fun|default|module|import|const\";\n      var builtinConstants = \"true|false|\" + categories.const;\n      var langVars = \"out|const\";\n      var std = categories.std;\n      var stdArr = categories[\"std.array\"];\n      var stdSeries = categories[\"std.series\"];\n      var math = categories.math;\n      var mathSeries = categories[\"math.series\"];\n      var mathExtended = categories[\"math.extended\"];\n      var mathArr = categories[\"math.array\"];\n      var types = categories.type;\n      var envFunctions = categories.util;\n      var DxScriptHighlightRules = function() {\n        function comments(next) {\n          return [\n            {\n              token: \"comment\",\n              // multi line comment\n              regex: /\\/\\*/,\n              next: [\n                { token: \"comment\", regex: \"\\\\*\\\\/\", next },\n                { defaultToken: \"comment\", caseInsensitive: true }\n              ]\n            },\n            {\n              token: \"comment\",\n              regex: \"\\\\/\\\\/\",\n              next: [\n                { token: \"comment\", regex: \"$|^\", next },\n                { defaultToken: \"comment\", caseInsensitive: true }\n              ]\n            }\n          ];\n        }\n        var idRe = \"[a-zA-Z_][a-zA-Z\\\\d_]*\\\\b\";\n        var operatorsMath = \"\\\\*|\\\\-|\\\\+|<=|>=|<|>\";\n        var operatorsLogic = \"!|%|&|==|=|!=|&&|\\\\|\\\\|\";\n        var keywordMapper = this.createKeywordMapper(\n          {\n            \"variable.language\": langVars,\n            keyword: keywords,\n            \"constant.language\": builtinConstants,\n            \"support.function\": [std, stdArr, stdSeries, math, mathExtended, mathArr, mathSeries].join(\"|\"),\n            \"support.function.editorenv\": envFunctions,\n            \"support.attribute\": types\n          },\n          \"identifier\"\n        );\n        this.$rules = {\n          start: [\n            comments(\"start\"),\n            {\n              token: [\"keyword\", \"text\", \"entity.name.function\"],\n              regex: /(fun)(\\s+)([a-zA-Z_][a-zA-Z\\d_]*)/\n            },\n            {\n              token: \"string\",\n              // single line\n              regex: /[\"](?:[^\"\\\\])*[\"]/\n            },\n            {\n              token: \"constant.numeric\",\n              // float\n              regex: /[+-]?\\d(?:_*\\d)*(?:(?:\\.\\d(?:_*\\d)*)?(?:[eE][+-]?\\d(?:_*\\d)*)?)?\\b/\n            },\n            {\n              token: \"constant.language.boolean\",\n              regex: \"(?:true|false)\\\\b\"\n            },\n            {\n              token: keywordMapper,\n              regex: idRe\n            },\n            {\n              token: \"keyword.operator.logic\",\n              regex: operatorsLogic\n            },\n            {\n              token: \"keyword.operator.math\",\n              regex: operatorsMath\n            },\n            {\n              token: \"lparen\",\n              regex: \"[[({]\"\n            },\n            {\n              token: \"rparen\",\n              regex: \"[\\\\])}]\"\n            },\n            {\n              token: \"text\",\n              regex: \"\\\\s+\"\n            }\n          ]\n        };\n        this.normalizeRules();\n      };\n      oop.inherits(DxScriptHighlightRules, TextHighlightRules);\n      exports.DxScriptHighlightRules = DxScriptHighlightRules;\n      exports.keywords = keywords;\n      exports.builtinConstants = builtinConstants;\n      exports.std = std;\n      exports.stdArr = stdArr;\n      exports.stdSeries = stdSeries;\n      exports.math = math;\n      exports.mathArr = mathArr;\n      exports.mathExtended = mathExtended;\n      exports.mathSeries = mathSeries;\n      exports.langVars = langVars;\n      exports.envFunctions = envFunctions;\n      exports.types = types;\n    }\n  );\n  ace.define(\n    \"ace/mode/matching_brace_outdent\",\n    [\"require\", \"exports\", \"module\", \"ace/range\"],\n    function(require, exports) {\n      var Range = require(\"../range\").Range;\n      var MatchingBraceOutdent = function() {\n      };\n      (function() {\n        this.checkOutdent = function(line, input) {\n          if (!/^\\s+$/.test(line))\n            return false;\n          return /^\\s*\\}/.test(input);\n        };\n        this.autoOutdent = function(doc, row) {\n          var line = doc.getLine(row);\n          var match = line.match(/^(\\s*\\})/);\n          if (!match)\n            return 0;\n          var column = match[1].length;\n          var openBracePos = doc.findMatchingBracket({\n            row,\n            column\n          });\n          if (!openBracePos || openBracePos.row === row)\n            return 0;\n          var indent = this.$getIndent(doc.getLine(openBracePos.row));\n          doc.replace(new Range(row, 0, row, column - 2), indent);\n        };\n        this.$getIndent = function(line) {\n          return line.match(/^\\s*/)[0];\n        };\n      }).call(MatchingBraceOutdent.prototype);\n      exports.MatchingBraceOutdent = MatchingBraceOutdent;\n    }\n  );\n  ace.define(\n    \"ace/mode/folding/cstyle\",\n    [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/range\", \"ace/mode/folding/fold_mode\"],\n    function(require, exports, module) {\n      var oop = require(\"../../lib/oop\");\n      var Range = require(\"../../range\").Range;\n      var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n      var FoldMode = exports.FoldMode = function(commentRegex) {\n        if (commentRegex) {\n          this.foldingStartMarker = new RegExp(\n            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n          );\n          this.foldingStopMarker = new RegExp(\n            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n          );\n        }\n      };\n      oop.inherits(FoldMode, BaseFoldMode);\n      (function() {\n        this.foldingStartMarker = /([{[])[^}\\]]*$|^\\s*(\\/\\*)/;\n        this.foldingStopMarker = /^[^[{]*([}\\]])|^[\\s*]*(\\*\\/)/;\n        this.singleLineBlockCommentRe = /^\\s*(\\/\\*).*\\*\\/\\s*$/;\n        this.tripleStarBlockCommentRe = /^\\s*(\\/\\*\\*\\*).*\\*\\/\\s*$/;\n        this.startRegionRe = /^\\s*(\\/\\*|\\/\\/)#?region\\b/;\n        this._getFoldWidgetBase = this.getFoldWidget;\n        this.getFoldWidget = function(session, foldStyle, row) {\n          var line = session.getLine(row);\n          if (this.singleLineBlockCommentRe.test(line)) {\n            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))\n              return \"\";\n          }\n          var fw = this._getFoldWidgetBase(session, foldStyle, row);\n          if (!fw && this.startRegionRe.test(line))\n            return \"start\";\n          return fw;\n        };\n        this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n          var line = session.getLine(row);\n          if (this.startRegionRe.test(line))\n            return this.getCommentRegionBlock(session, line, row);\n          var match = line.match(this.foldingStartMarker);\n          if (match) {\n            var i = match.index;\n            if (match[1])\n              return this.openingBracketBlock(session, match[1], row, i);\n            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n            if (range && !range.isMultiLine()) {\n              if (forceMultiline) {\n                range = this.getSectionRange(session, row);\n              } else if (foldStyle !== \"all\")\n                range = null;\n            }\n            return range;\n          }\n          if (foldStyle === \"markbegin\")\n            return;\n          match = line.match(this.foldingStopMarker);\n          if (match) {\n            var j = match.index + match[0].length;\n            if (match[1])\n              return this.closingBracketBlock(session, match[1], row, j);\n            return session.getCommentFoldRange(row, j, -1);\n          }\n        };\n        this.getSectionRange = function(session, row) {\n          var line = session.getLine(row);\n          var startIndent = line.search(/\\S/);\n          var startRow = row;\n          var startColumn = line.length;\n          row = row + 1;\n          var endRow = row;\n          var maxRow = session.getLength();\n          while (++row < maxRow) {\n            line = session.getLine(row);\n            var indent = line.search(/\\S/);\n            if (indent === -1)\n              continue;\n            if (startIndent > indent)\n              break;\n            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n            if (subRange) {\n              if (subRange.start.row <= startRow) {\n                break;\n              } else if (subRange.isMultiLine()) {\n                row = subRange.end.row;\n              } else if (startIndent === indent) {\n                break;\n              }\n            }\n            endRow = row;\n          }\n          return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n        };\n        this.getCommentRegionBlock = function(session, line, row) {\n          var startColumn = line.search(/\\s*$/);\n          var maxRow = session.getLength();\n          var startRow = row;\n          var re = /^\\s*(?:\\/\\*|\\/\\/|--)#?(end)?region\\b/;\n          var depth = 1;\n          while (++row < maxRow) {\n            line = session.getLine(row);\n            var m = re.exec(line);\n            if (!m)\n              continue;\n            if (m[1])\n              depth--;\n            else\n              depth++;\n            if (!depth)\n              break;\n          }\n          var endRow = row;\n          if (endRow > startRow) {\n            return new Range(startRow, startColumn, endRow, line.length);\n          }\n        };\n      }).call(FoldMode.prototype);\n    }\n  );\n  ace.define(\"ace/snippets/dxscript\", [\"require\", \"exports\", \"module\"], function(require, exports) {\n    exports.snippets = [\n      {\n        name: \"in\",\n        tabTrigger: \"in\",\n        content: \"in ${1:name} = ${2:expr}$0\"\n      },\n      {\n        name: \"out\",\n        tabTrigger: \"out\",\n        content: \"out ${1:name} = ${2:expr}$0\"\n      },\n      {\n        name: \"set\",\n        tabTrigger: \"set\",\n        content: \"set ${1:name} = ${2:expr}$0\"\n      },\n      {\n        name: \"def\",\n        tabTrigger: \"def\",\n        content: \"def ${1:name} = ${2:expr}$0\"\n      },\n      {\n        name: \"ifs\",\n        tabTrigger: \"ifs\",\n        content: \"if (${1:condition}) {\\n\t${0}\\n} else {\\n\t\\n}\"\n      },\n      {\n        name: \"if\",\n        tabTrigger: \"if\",\n        content: \"if (${1:condition}) ${2:onTrue} else ${3:onFalse}\"\n      }\n    ];\n    exports.scope = \"dxscript\";\n  });\n  ace.define(\n    \"ace/mode/dxscript\",\n    [\n      \"require\",\n      \"exports\",\n      \"module\",\n      \"ace/lib/oop\",\n      \"ace/mode/text\",\n      \"ace/mode/dxscript_highlight_rules\",\n      \"ace/mode/matching_brace_outdent\",\n      \"ace/mode/folding/cstyle\",\n      \"ace/range\"\n    ],\n    function(require, exports) {\n      var oop = require(\"../lib/oop\");\n      var Range = require(\"../range\").Range;\n      var TextMode = require(\"./text\").Mode;\n      var HighlightRules = require(\"./dxscript_highlight_rules\");\n      var DxScriptHighlightRules = HighlightRules.DxScriptHighlightRules;\n      var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n      var CStyleFoldMode = require(\"./folding/cstyle\").FoldMode;\n      var Mode = function() {\n        this.HighlightRules = DxScriptHighlightRules;\n        this.$outdent = new MatchingBraceOutdent();\n        this.foldingRules = new CStyleFoldMode();\n      };\n      oop.inherits(Mode, TextMode);\n      var completionCategories = [\n        {\n          meta: \"keyword\",\n          regex: HighlightRules.keywords\n        },\n        {\n          meta: \"const\",\n          regex: HighlightRules.builtinConstants\n        },\n        {\n          meta: \"std\",\n          regex: HighlightRules.std\n        },\n        {\n          meta: \"std.array\",\n          regex: HighlightRules.stdArr\n        },\n        {\n          meta: \"std.series\",\n          regex: HighlightRules.stdSeries\n        },\n        {\n          meta: \"Math\",\n          regex: HighlightRules.math\n        },\n        {\n          meta: \"Math.series\",\n          regex: HighlightRules.mathSeries\n        },\n        {\n          meta: \"Math.array\",\n          regex: HighlightRules.mathArr\n        },\n        {\n          meta: \"Math.extended\",\n          regex: HighlightRules.mathExtended\n        },\n        {\n          meta: \"special\",\n          regex: HighlightRules.langVars\n        },\n        {\n          meta: \"env\",\n          regex: HighlightRules.envFunctions\n        },\n        {\n          meta: \"type\",\n          regex: HighlightRules.types\n        }\n      ];\n      var highlightCompletions = completionCategories.map(function(category) {\n        return category.regex.split(\"|\").map(function(item) {\n          return {\n            caption: item,\n            value: item,\n            meta: category.meta\n          };\n        });\n      }).reduce(function(a, b) {\n        return a.concat(b);\n      }, []);\n      var declRegex = new RegExp(\"(?:in|def|out|set)\\\\s+([a-zA-Z_0-9\\\\u00C0-\\\\u1FFF\\\\u2C00-\\\\uD7FF\\\\w]+)\", \"g\");\n      function getDeclarationsBefore(doc, pos) {\n        var textBefore = doc.getTextRange(Range.fromPoints({ row: 0, column: 0 }, pos));\n        var splitResult = textBefore.match(declRegex);\n        return splitResult ? splitResult.map(function(decl) {\n          return decl.match(/\\S+$/)[0];\n        }) : [];\n      }\n      (function() {\n        this.foldingRules = \"cStyle\";\n        this.blockComment = {\n          start: \"/*\",\n          end: \"*/\"\n        };\n        this.getNextLineIndent = function(state, line, tab) {\n          var indent = this.$getIndent(line);\n          var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n          if (tokens.length && tokens[tokens.length - 1].type === \"comment\") {\n            return indent;\n          }\n          var match = line.match(/^.*\\{\\s*$/);\n          if (match) {\n            indent += tab;\n          }\n          return indent;\n        };\n        this.checkOutdent = function(state, line, input) {\n          return this.$outdent.checkOutdent(line, input);\n        };\n        this.autoOutdent = function(state, doc, row) {\n          this.$outdent.autoOutdent(doc, row);\n        };\n        this.createWorker = function() {\n          return null;\n        };\n        this.getCompletions = function(scope, session, pos, prefix) {\n          if (prefix !== \"\" && !isNaN(prefix)) {\n            return [];\n          }\n          if (prefix.match(/\\.\\s*$/)) {\n            return [];\n          }\n          var localCompletions = getDeclarationsBefore(session, pos).map(function(decl) {\n            return {\n              caption: decl,\n              value: decl,\n              score: 10,\n              meta: \"local\"\n            };\n          });\n          return highlightCompletions.concat(localCompletions);\n        };\n        this.$id = \"ace/mode/dxscript\";\n      }).call(Mode.prototype);\n      exports.Mode = Mode;\n    }\n  );\n}\n\n\n//# sourceURL=webpack://DXchart/./src/chart/components/code-editor/dxScript/mode-dxscript.js?");

/***/ })

}]);